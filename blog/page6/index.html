<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Jeff Lindsay, Open source hacker</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/blog/atom.xml" />
    <link rel="shortcut icon" type="image/x-icon" href="/images/JeffLindsayDeluxe.png" />
    <link href='https://fonts.googleapis.com/css?family=Dosis:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300,700|Lora:400,700,400italic|Vollkorn:400,700' rel='stylesheet' type='text/css'>
    <link href="/stylesheets/all.css" rel="stylesheet" />
    
  </head>
  <body>
  <div id="wrapper">

    <header>
  <div class="container">
  <div class="row">
      <div class="col-lg-8 col-lg-offset-1">
        You're reading the <a href="/blog">blog</a> of Jeff Lindsay (<a href="http://twitter.com/progrium">@progrium</a>). There is also his <a href="/wiki">wiki</a>.
      </div>
  </div>
</div>
</header>

<main id="main" role="main">
  <section>
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Jan</span>
                    <span class="day">05</span>
                    <span class="year">2013</span>
                </div>
            </div>
            <h1><a href="/blog/2013/01/05/executable-tweets-and-programs-in-short-urls/">Executable Tweets and Programs in Short URLs</a></h1>
            <p>A few weeks ago I was completely consumed for
the better part of a day that I would have otherwise spent on more practical
work.</p>

<blockquote class="twitter-tweet tw-align-center"><p>Let's reflect. On a whim, I spent 6 hours writing programs that live in URL shorteners to create installable programs from Tweets.</p>&mdash; Jeff Lindsay (@progrium) <a href="https://twitter.com/progrium/status/279118756561711104" data-datetime="2012-12-13T07:01:11+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<p>Yeah, what? Weird, right? It started from a Twitter conversation earlier that day with my friend Joel:</p>

<blockquote class="twitter-tweet tw-align-center"><p>$ for app in `heroku apps | grep -v '='`; do echo <a href="https://twitter.com/search/$app">$app</a>; heroku ps --app <a href="https://twitter.com/search/$app">$app</a>; done # how to figure out what you have running on heroku</p>&mdash; Joël Franusic (@jf) <a href="https://twitter.com/jf/status/279030460674347008" data-datetime="2012-12-13T01:10:20+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279030460674347008"><p>@<a href="https://twitter.com/jf">jf</a> reminds me of yet another app i need to build</p>&mdash; Jeff Lindsay (@progrium) <a href="https://twitter.com/progrium/status/279030609345667072" data-datetime="2012-12-13T01:10:56+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279030609345667072"><p>@<a href="https://twitter.com/progrium">progrium</a> I just wrote and launched a "client side" "bash app" right there. Bam.</p>&mdash; Joël Franusic (@jf) <a href="https://twitter.com/jf/status/279031831809097728" data-datetime="2012-12-13T01:15:47+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279031831809097728"><p>@<a href="https://twitter.com/jf">jf</a> app tweets. an app in a tweet.</p>&mdash; Jeff Lindsay (@progrium) <a href="https://twitter.com/progrium/status/279032107265839104" data-datetime="2012-12-13T01:16:53+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279032107265839104"><p>@<a href="https://twitter.com/progrium">progrium</a> $ apptweet install id:279030460674347008</p>&mdash; Joël Franusic (@jf) <a href="https://twitter.com/jf/status/279032681373790208" data-datetime="2012-12-13T01:19:10+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<p>This wishful brainstorming inspired me to start building exactly that.
But first, a digression.</p>

<p>The idea reminded me of an idea I got from <a href="https://twitter.com/rndmcnlly">Adam
Smith</a> back when I was working on
Scriptlets. If you can execute code from a URL, you could "store" a
program in a shortened URL. I decided to combine this with the
curl-pipe-bash technique that's been starting to get popular to
bootstrap installs. If you're unfamiliar, take this Gist of a Bash
script:</p>

<script src="https://gist.github.com/4464431.js"> </script>

<p>Given the "view raw" URL for that Gist, you can curl it and pipe it into Bash to
execute it right there in your shell. It would look like this:</p>

<pre class="highlight plaintext"><code>$ curl -s https://gist.github.com/raw/4464431/gistfile1.txt | bash
Hello world
</code></pre>

<p>Instead of having Gist store the program, how could we make it so the
source would just live within the URL? Well in the case of
curl-pipe-bash, we just need that source to be returned in the body of a
URL. So I built a simple app to run on Heroku that takes the query
string and outputs it in the body, a sort of echo service.</p>

<script src="https://gist.github.com/4464442.js"> </script>

<p>Letting you do this:</p>

<pre class="highlight plaintext"><code>$ curl "http://queryecho.herokuapp.com?Hello+world"
Hello world
</code></pre>

<p>Which you could conceal and shorten with a URL shortener, like Bitly. I
prefer the j.mp domain Bitly has. And since they're just redirecting you to the
long URL, you'd use the <code>-L</code> option in curl to make it follow redirects:</p>

<pre class="highlight plaintext"><code>$ curl -L http://j.mp/RyUN03
Hello world
</code></pre>

<p>When you make a short URL from the bitly website, they conveniently make
sure the query string is properly URL encoded. So if I just typed
<code>queryecho.herokuapp.com/?echo "Hello world"</code> into bitly, it
would give me a short URL with a properly URL encoded version of that
URL that would return <code>echo "Hello world"</code>. This URL we could then curl-pipe into Bash:</p>

<pre class="highlight plaintext"><code>$ curl -Ls http://j.mp/VGgI3o | bash
Hello world
</code></pre>

<p>See what's going on there? We wrote a simple Hello world program in Bash
that effectively lives in that short URL. And we can run it with
the curl-pipe-bash technique.</p>

<p>Later in our conversation, Joel suggests an example "app tweet" that if
executed in Bash given a URL argument, it would tell you where it
redirects. So if you gave it a short URL, it would tell you the long
URL.</p>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279032107265839104"><p>@<a href="https://twitter.com/progrium">progrium</a> $ echo "$1"; curl -IL --silent "$1" | grep Location | grep -o 'http.*' # this is a URL "unshortener"</p>&mdash; Joël Franusic (@jf) <a href="https://twitter.com/jf/status/279033679592951809" data-datetime="2012-12-13T01:23:08+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<p>Just so you know what it would look like, if you put that program in a
shell script and ran it against a short URL that redirected to www.google.com, this is what you would see:</p>

<pre class="highlight plaintext"><code>$ ./unshortener.sh http://j.mp/www-google-com
http://j.mp/www-google-com
http://www.google.com/
</code></pre>

<p>It prints the URL you gave it and then resolves the URL and
prints the long URL. Pretty simple.</p>

<p>So I decided to put this program in a short URL. Here we have <a href="http://j.mp/TaHyRh">j.mp/TaHyRh</a> which will resolve to:</p>

<pre class="highlight plaintext"><code>http://queryecho.herokuapp.com/?echo%20%22$url%22;%20curl%20-ILs%20%22$url%22%20|%20grep%20Location%20|%20grep%20-o%20'http.*'
</code></pre>

<p>Luckily I didn't have to do all that URL encoding. I just pasted his
code in after <code>queryecho.herokuapp.com/?</code> and bitly took care of it.
What's funny is that this example program is made to run on short URLs,
so when I told him about it, my example ran on the short URL that
contained the program itself:</p>

<pre class="highlight plaintext"><code>$ curl -Ls http://j.mp/TaHyRh | url=http://j.mp/TaHyRh bash
http://j.mp/TaHyRh
http://queryecho.herokuapp.com/?echo "$url"; curl -ILs "$url" | grep Location | grep -o 'http.*'
</code></pre>

<p>You may have noticed my version of the program uses <code>$url</code> instead of
<code>$1</code> because we have to use environment variables to provide input to
curl-pipe-bash scripts. For reference, to run my URL script against the
google.com short URL we made before, it would look like this:</p>

<pre class="highlight plaintext"><code>$ curl -Ls http://j.mp/TaHyRh | url=http://j.mp/www-google-com bash
http://j.mp/www-google-com
http://www.google.com/
</code></pre>

<p>Okay, so we can now put Bash scripts in short URLs. What happened to
installing apps in Tweets? Building an <code>apptweet</code> program like Joel
imagined would actually be pretty straightforward. But I wanted to build
it in and install it with these weird programs-in-short-URLs.</p>

<p>The first obstacle was figuring out how to get it to modify your current
environment. Normally curl-pipe-bash URLs install a downloaded program
into your <code>PATH</code>. But I didn't want to install a bunch of files on your
computer. Instead I just wanted to install a temporary Bash function
that would disappear when you leave your shell session. In order to do
this, I had to do a variant of the curl-pipe-bash technique using eval:</p>

<pre class="highlight plaintext"><code>$ eval $(curl -Ls http://j.mp/setup-fetchtweet)
$ fetchtweet 279072855206031360
@jf you asked for it... Jeff Lindsay (@progrium) December 13, 2012
</code></pre>

<p>As you can see by inspecting that URL, it just defines a Bash function
that runs a Python script from a Gist. I cheated and used Gist for some
reason. That Python script uses the Twitter embed endpoint (same one
used for the embedded Tweets in this post) to get the contents of a
Tweet without authentication.</p>

<p>The next thing I built installed and used fetchtweet
to get a Tweet, parse it, put it in a Bash function named by the string
after an <code>#exectweet</code> hashtag (which happens to also start a comment in Bash). So here we have a Tweet with a program in it:</p>

<blockquote class="twitter-tweet tw-align-center"><p>echo Hello world <a href="https://twitter.com/search/%23exectweet">#exectweet</a> helloworld</p>&mdash; Jeff Lindsay (@progrium) <a href="https://twitter.com/progrium/status/279087620145958912" data-datetime="2012-12-13T04:57:28+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<p>To install it, we'd run this:</p>

<pre class="highlight plaintext"><code>$ id=279087620145958912 eval $(curl -Ls http://j.mp/install-tweet)
Installed helloworld from Tweet 279087620145958912
$ helloworld
Hello world
</code></pre>

<p>We just installed a program from a Tweet and ran it! Then I wrapped this
up into a command you could install. To install the installer. This time it would let you give it the URL to a Tweet:</p>

<pre class="highlight plaintext"><code>$ eval $(curl -Ls http://j.mp/install-exectweet) 
Installed exectweet
$ exectweet https://twitter.com/progrium/status/279087620145958912
Installed helloworld from Tweet 279087620145958912
$ helloworld
Hello world
</code></pre>

<p>Where would I go from there? An app that calls itself into a loop, of course!</p>

<blockquote class="twitter-tweet tw-align-center"><p>exectweet <a href="http://t.co/ri0XTprA" title="http://j.mp/recursive-app">j.mp/recursive-app</a> ; recursive-app <a href="https://twitter.com/search/%23exectweet">#exectweet</a> recursive-app</p>&mdash; Jeff Lindsay (@progrium) <a href="https://twitter.com/progrium/status/279123541054595074" data-datetime="2012-12-13T07:20:12+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<pre class="highlight plaintext"><code>$ exectweet https://twitter.com/progrium/status/279123541054595074 &amp;&amp; recursive-app
Installed recursive-app from Tweet 279123541054595074
Installed recursive-app from Tweet 279123541054595074
Installed recursive-app from Tweet 279123541054595074
Installed recursive-app from Tweet 279123541054595074
...
</code></pre>

<p>Obviously, this whole project was just a ridiculous, mind-bending exploration.
I shared most of these examples on Twitter as I was making them. Here
was my favorite response.</p>

<blockquote class="twitter-tweet tw-align-center" data-in-reply-to="279087620145958912"><p>@<a href="https://twitter.com/progrium">progrium</a> End of the world, brought to you by Jeff Lindsay, via the Internet collapsing in on itself and taking the world with it.</p>&mdash; Matt Mechtley (@biphenyl) <a href="https://twitter.com/biphenyl/status/279088441084497922" data-datetime="2012-12-13T05:00:44+00:00">December 12, 2012</a></blockquote>
<script src="//platform.twitter.com/widgets.js" charset="utf-8"> </script>

<p>You may have noticed, it just happened to be 12/12/2012 that day.</p>

<style type="text/css">
.twitter-tweet-rendered {
  clear: none!important;
}
.twt-reply {
  display: none!important;
}
</style>


          </article>
          <a href="/blog/2013/01/05/executable-tweets-and-programs-in-short-urls/#disqus_thread">Comments</a>
          <br /><br />
        </div>

        <div class="col-lg-3" id="sidebar">
    <img src="https://dl.dropboxusercontent.com/u/2096290/Blog/progrium2016.png" id="photo" title="Jeff Lindsay" />
    <p>
        Jeff Lindsay is a design-minded software programmer living in Austin, Texas. 
    </p>
    <p>
        He founded <a href="http://gliderlabs.com">Glider Labs</a>, an open source innovation lab.
        There he writes <a href="http://gliderlabs.com/projects">open source developer infrastructure</a> 
        to make the world more programmable.
    </p>
    <p><a href="/wiki/InfluenceAndAffiliations/">Learn more about Jeff.</a></p>
    <h5>
      <a rel="me" href="https://twitter.com/progrium"><i class="fa fa-twitter-square fa-2x"></i></a>
      <a rel="me" href="https://github.com/progrium"><i class="fa fa-github fa-2x"></i></a>
      <a ref="me" href="https://instagram.com/progrium"><i class="fa fa-instagram fa-2x"></i></a>
      <a ref="me" href="https://vimeo.com/progrium"><i class="fa fa-vimeo-square fa-2x"></i></a>
    </h5>
</div>

    </div>
</div>
</section>

<section class="subscribe" style="padding: 20px 0;">
  <div class="row">
  <div class="col-lg-8 col-lg-offset-1">
    <i class="fa fa-envelope"></i>
    <a href="http://eepurl.com/bUo8Rb">Subscribe</a> to get future blog posts sent to you via email.
  </div>
  </div>
</section>


<section  class="alternate">
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Jan</span>
                    <span class="day">01</span>
                    <span class="year">2013</span>
                </div>
            </div>
            <h1><a href="/blog/2013/01/01/where-did-localtunnel-come-from/">Where did Localtunnel come from?</a></h1>
            <p>Five years ago, async network programming scared me. I was a web developer. Working with the high level tools and frameworks of HTTP seemed much easier than any sort of serious low level networking. Especially since network programming would often also mean some kind of concurrent programming with threads or callbacks. I had mostly avoided multithreading and had no idea what an event loop was. I came from PHP.</p>

<p>Around 2007, I was starting to think about webhooks. One motivator was how you could use webhooks to let web developers, like me, build systems that used other protocols without them having to work with that protocol. For example, one of my first projects with webhooks was called Mailhooks. I wanted to accept email in my application, but I didn't want to deal with email servers. I wanted to get an HTTP POST when an email came in with all the email fields nicely provided as POST parameters.</p>

<p>This is how I started working with Twisted. Twisted became my main tool to build webhook adapters for existing protocols. I even tried to generalize that idea in a project called Protocol Droid. Slowly I started to grok, and not fear, this kind of programming.</p>

<p>It's funny how my desire to work with abstractions that didn't exist yet to avoid a certain kind of programming was directly responsible for me eventually becoming an expert in that kind of programming.</p>

<p>Then in late 2009, I had another idea while thinking about webhooks. It would be great if I could expose a local web server to the Internet with a friendly URL. It should just be a simple command. There would have to be a server, but there could just be a public server that you didn't even have to think about.</p>

<p>I committed <a href="https://github.com/progrium/localtunnel/tree/prototype">the first prototype of Localtunnel</a> to Github in January 2010. It was written entirely in Twisted. It also didn't actually work. I really recommend taking a look because it was terrible. One of the challenges was multiplexing the HTTP requests into a single tunnel connection. My approach was so naive it just didn't work. As soon as you made more than one request at a time, it broke.</p>

<p>A few months later, I decided to take a different approach. Instead of doing my own protocol, client, and server, I'd just make a wrapper around what I knew already worked: SSH tunneling. This was pretty quick to make happen, and that version is basically what's been in production to this day.</p>

<p>This shortcut came with a lot of weird quirks. For example, the easiest way I found to implement an SSH tunnel client was a Ruby library, so I implemented the client in Ruby. The server, though, was in Python because I still only really knew Twisted for evented programming.</p>

<p>Actually, using SSH was the source of most of the quirks and annoyances. I was pretty bothered that it slowed down the initial user experience by requiring a public key to be uploaded. But most of the pain was operational. The server, sshd, would create a process for every tunnel. Localtunnel also needed its own user and to pretty much own the SSH configuration for that machine. Then, on occasion, something weird would happen where a tunnel would die and the process would go crazy eating up CPU. It would have to be manually killed or it would eventually bring the server to a halt. And, eventually, the authorized_keys file would become enormous from all the keys uploaded.</p>

<p>On top of all this, SSH is pretty opaque. It's been around for so long and used so much that it certainly just works … you just don't really know how. I still don't know how SSH does tunneling or what the protocol looks like, even after trying to read the RFC for it.</p>

<p>By mid-2011, I was working at Twilio building distributed, real-time messaging systems at scale. I certainly came a long way from fearing async network programming. Localtunnel was still running the implementation based on SSH. By then it had quite a large user base and collected a number of bugs and feature requests. I also had my own operations and user experience wish list. With such a huge list of new requirements, so many problems with the current implementation, and a drastically different experience level and mindset, I decided to redesign Localtunnel from the ground up.</p>

<p>Since I was pretty consumed by Twilio, I didn't have a lot of time to work on Localtunnel. I thought the biggest bang for buck in the long term would be to slowly work on the new version. They say software is never done, but I personally believe software can be finished. It just requires an aggressive drive for simplicity, and the <em>only</em> way you can make significant advances in simplicity is through redesign.</p>

<p>In the meantime, users continued to experience issues with the current implementation. These problems only got worse as it became more popular. For example, the biggest issue was that the namespace for tunnel names was too small. Users would get requests from old tunnels, and in rare cases tunnel names would get pulled out from under you while using them. This created confusion and a lot of emails and issue tickets, but it still worked with the occasional restart.</p>

<p>I've used this constant stream of complaints, which has been going on for almost two years, to make sure I keep making progress on the new version. In fact, I'm pretty sure I needed it because of my lifestyle of abundant projects.</p>

<p>Last week I finally <a href="http://progrium.com/blog/2012/12/25/localtunnel-v2-available-in-beta/">released a beta of the new version</a>. What's interesting is that it's a completely different architecture from what I started out with for the redesign. After the original unreleased prototype, there's been 3 major approaches to implementation. In the coming weeks I'm going to share a more technical history of the architecture of Localtunnel, leading up to a deep exploration of what I hope will be its final form.</p>

          </article>
          <a href="/blog/2013/01/01/where-did-localtunnel-come-from/#disqus_thread">Comments</a>
        </div>
    </div>
</div>
</section>
<section >
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-1">
          <article>
            <div class="meta">
                <div class="date">
                    <span class="month">Dec</span>
                    <span class="day">25</span>
                    <span class="year">2012</span>
                </div>
            </div>
            <h1><a href="/blog/2012/12/25/localtunnel-v2-available-in-beta/">Localtunnel v2 available in beta</a></h1>
            <p>A few years back, I released <a href="http://localtunnel.com">Localtunnel</a> to make it super easy to expose a local web server to the Internet for demos and debugging. Since then, it's gotten a ton of use. A few people even copied it and tried to make a paid service around the idea. Luckily, Localtunnel will always be free and open source.</p>

<p>With the release of <a href="http://j.mp/localtunnel-v2">Localtunnel v2</a>, it will not only remain competitive with similar services, but continue to be the innovator of the group. I'll post more on this later.</p>

<p>For now, let's talk logistics. The current, soon-to-be-legacy Localtunnel stack includes the client that you install with Rubygems, and a server that runs on a host at Rackspace. These will continue to be available into 2013, but will be marked as deprecated. This means you should be making the switch to v2.</p>

<p>Besides the fact v1 will eventually be shutdown, there are a number of reasons to switch to v2. Here are some of the major ones:</p>

<ul>
  <li>It's actively maintained. Bug reports, pull requests, and service interruptions are dealt with promptly.</li>
  <li>No more mysterious requests from old tunnels. The subdomain namespace is much larger.</li>
  <li>Custom subdomains. The new client lets you pick a tunnel name on a first come, first served basis.</li>
  <li>Supports long-polling, HTTP streaming, and WebSocket upgrades. Soon general TCP tunneling.</li>
  <li>No SSH key to start using it. A minor annoyance setting up v1, but it doesn't exist in v2.</li>
</ul>

<p>One implementation detail that affects users is that the client is now written in Python. This means you won't use Rubygems to install it. Instead, you can use <code>easy_install</code> or <code>pip</code>.</p>

<pre class="highlight plaintext"><code>$ easy_install localtunnel
</code></pre>

<p>On some systems, you may need to run this with <code>sudo</code>. If you don't have <code>easy_install</code>, first make sure you have Python installed:</p>

<pre class="highlight plaintext"><code>$ python --version
</code></pre>

<p>Localtunnel requires Python 2.6 or later, which comes standard on most systems. If you don't have Python, you can <a href="http://wiki.python.org/moin/BeginnersGuide/Download">install it for your platform</a>. If <code>easy_install</code> isn't available after you install Python, you can install it with this bootstrap script:</p>

<pre class="highlight plaintext"><code>$ curl http://peak.telecommunity.com/dist/ez_setup.py | python
</code></pre>

<p>Once you've installed Localtunnel with <code>easy_install</code>, it will be available as <code>localtunnel-beta</code>. This lets you keep the old client to use in case anything goes wrong with v2 during the beta. Eventually, it will be installed as <code>localtunnel</code>, but only after v1 is shutdown.</p>

<p>Using <code>localtunnel-beta</code> is pretty much the same as before:</p>

<pre class="highlight plaintext"><code>$ localtunnel-beta 8000
  Thanks for trying localtunnel v2 beta!

  Port 8000 is now accessible from http://fb0322605126.v2.localtunnel.com ...
</code></pre>

<p>Like I mentioned earlier, you can use a custom tunnel name if it's not being used:</p>

<pre class="highlight plaintext"><code>$ localtunnel-beta -n foobar 8000
  Thanks for trying localtunnel v2 beta!

  Port 8000 is now accessible from http://foobar.v2.localtunnel.com ...
</code></pre>

<p>Keep in mind v2 is in active development. There might be some downtime while I work out operational bugs, but you can always use the old version if you run into problems.</p>

<p>If you do run into any problems, you can <a href="http://twitter.com/progrium">ping me on Twitter</a>. If you get traceback you can <a href="https://github.com/progrium/localtunnel/issues">create an issue on Github</a>. If you have more in-depth questions or want to get involved in development, check out the <a href="https://groups.google.com/forum/#!forum/localtunnel">Localtunnel Google Group</a>.</p>


          </article>
          <a href="/blog/2012/12/25/localtunnel-v2-available-in-beta/#disqus_thread">Comments</a>
        </div>
    </div>
</div>
</section>


<section class="alternate">
<div class="container">
    <div class="row">
        <div class="col-lg-12">
        <ul class="pager article">
          <li class="previous">
            <a href="/blog/page7/">&larr; Older</a>
          </li>

          <li class="next">
            <a href="/blog/page5/">Newer &rarr;</a>
          </li>
        </ul>
        </div>
    </div>
</div>
</section>

</main>



    <footer>
      <div class="container clearfix">
        &copy; 2017 Jeff Lindsay
      </div>
    </footer>

  </div>
  <script src="/javascripts/all.js"></script>
  <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script>
        <script type="text/javascript">
        try {
        var pageTracker = _gat._getTracker("UA-6824126-1");
        pageTracker._trackPageview();
        } catch(err) {}</script>
    <!--script type="text/javascript">
      var host = "progrium.com";
      if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
    </script-->
    <script type="text/javascript">
      
    </script>
  </body>
</html>
